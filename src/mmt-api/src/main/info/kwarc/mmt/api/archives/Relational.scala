package info.kwarc.mmt.api.archives

import dotty.tools.io.File
import info.kwarc.mmt.api._
import frontend._

/** an object to extract dependencies from a controller */
object Relational {
  // The actual sorting algorithm.
  private def topsort[A](controller: Controller, m: Map[A, Set[A]]) : Option[List[Set[A]]] = {
    if (m.isEmpty) Some(Nil)
    else {
      val (noDeps, rest) = m.partition(_._2.isEmpty)
      if (noDeps.isEmpty) {
        controller.report(new Error(shortMsg = "cyclic dependencies: " + m) {})
        None
      }
      else {
        val fst : Set[A] = noDeps.keySet
        topsort(controller, rest.map(p => (p._1, p._2.diff(fst)))).map(olsa => fst :: olsa)
      }
    }
  }

  /**
    * Method for topologically sorting a collection of As into a list.
    * @param controller The controller to report errors to.
    * @param depsMap the collection in the form of a dependency Map as generated by getDepsMap.
    * @param byName Should the secondary sorting be by name (true) or by dependency closure size (false)?
    * @tparam A Type parameter for the collection to be sorted.
    * @return None, if there are cycles in the map. Some() of a topologically sorted list otherwise.
    */
  def flatTopsort[A](controller: Controller, depsMap: Map[A, Set[A]], byName : Boolean = true): Option[List[A]] = {
    val sorted = topsort(controller, depsMap)
    if (sorted.isEmpty) {
      Dot.generateDot(name = "cyclic_dependencies", Dot.dependencyNodeName[A],List(depsMap.keySet),depsMap)
      return None
    }

    // Can be commented to also generate a .dot-File for the complete dependency graph.
    // Dot.generateDot(name = "complete_dependency_graph", Dot.dependencyNodeName[A], sorted.get, depsMap)

    if (byName) {
      Some(sorted.get.flatMap(_.toList.sortBy(_.toString)))
    } else {
      Some(sorted.get.flatMap(_.toList.sortBy(d => dependencyClosure(Set(d), depsMap).size)))
    }
  }

  // Finding the complete dependency closure of a set of roots in the collection.
  private def dependencyClosure[A](roots : Set[A], m : Map[A, Set[A]]) : Set[A] = {
    var closure : Set[A] = roots
    var newdeps : Set[A] = closure.flatMap(m(_))
    while (closure.union(newdeps).size > closure.size) {
      val newest : Set[A] = newdeps.flatMap(m(_))
      closure = closure.union(newdeps)
      newdeps = newest
    }
    closure
  }
}

// Dot generation for debugging purposes.
object Dot {

  /* Generates a dot-file for easier viewing of the dependency graph */
  def generateDot[A](name : String, f : A => String, l : List[Set[A]], m : Map[A,Set[A]]) : Unit = {
    val w = new StringBuilder
    def writeln(s: String): Unit = w.append(s + "\n")
    writeln("digraph " + name + " {")

    var nodes : Set[String] = Set.empty
    // Idempotent, adding the same node twice doesn't change anything.
    def newnode(arg : A, important : Int = 0) : Unit = {
      if (!nodes.contains(f(arg))) {
        val extra = if (important == 2) {
          "[shape=box style=filled fillcolor=green]"
        } else if (important == 1) {
          "[shape=box style=filled fillcolor=gold]"
        } else {
          "[shape=oval style=filled fillcolor=white]"
        }
        writeln("    " + f(arg) + extra + ";")
        nodes += f(arg)
      }
    }

    def isImportant(d : A) : Int = d match {
      case FileBuildDependency("alltex",_,_) => if (!m.keySet.contains(d) || m(d).isEmpty) { 2 } else { 1 }
      case _ => 0
    }

    for (s <- l) {
      for (e <- s) {
        newnode(e,important = isImportant(e))
        for (tar <- m(e)) {
          newnode(tar, important = isImportant(tar))
          writeln("    " + f(e) + " -> " + f(tar) + ";")
        }
      }
    }

    writeln("}")
    File(name + ".dot").writeAll(w.result())
    //reflect.io.File(name + ".dot").writeAll(w.result())
  }

  def dependencyNodeName[A](d : A) : String = d match {
      case FileBuildDependency(k,_,i) => "\"" + i + "\n(" + k + ")\""
      case PhysicalDependency(f) => "\"" + f.toFilePath.tail.tail.tail.tail.tail.mkString("/") + "\""
      case _ => "other"
  }
}
