package info.kwarc.mmt.jedit

import errorlist._
import info.kwarc.mmt.api._
import archives.source
import frontend._
import objects._
import org.gjt.sp.jedit.jEdit
import parser._
import utils.MyList._
import utils._

/** customizes the default errors of the ErrorList plugin
 *  @param mainFile the file whose checking led to the error (may differ from the file that contains the error)
 */
/* ErrorList weirdly errors that have the same error message (even if they are in different lines).
   So we add the error hash to the messages to make them all unique.
 */
class MMTError(val mainFile: File, es: ErrorSource, error: Error, sf: String, sl: Int, sc: Int, ec: Int, msg: String, extraMsg: List[String])
   extends DefaultErrorSource.DefaultError(es, MMTError.mmtLevelTojEditLevel(error), sf, sl, sc, ec, msg + s"    (error hash: ${error.hashCode().toString})") {
  extraMsg foreach {m => addExtraMessage(m)}
}

object MMTError {
  def apply(mainFile: File, es: ErrorSource, e: Error, sf: String, reg: SourceRegion, msg: String, extraMsg: List[String]) = {
     val pos = reg.start
     try {
       val (line,column) = if (pos.line == -1 || pos.column == -1) {
         // unknown line/column: compute from offset
         val buf = jEdit.getBuffer(mainFile.toString) //TODO does this actually find the buffer?
         val l = buf.getLineOfOffset(pos.offset)
         (l, pos.offset-buf.getLineStartOffset(l))
       } else
         (pos.line,pos.column)
       new MMTError(mainFile, es, e, sf, line, column, column + reg.length, msg, extraMsg)
     } catch {
       case t: Exception =>
         val tMsg = "error while creating error (illegal region?: " + reg + ")" 
         new MMTError(mainFile, es, e, sf, 0, 0, 1, tMsg, msg :: extraMsg)
     }
  }
  def mmtLevelTojEditLevel(e: Error): Int = if (e.level >= Level.Error && e.excuse.isEmpty) ErrorSource.ERROR else ErrorSource.WARNING
}
   
/** customizes the default error source of the ErrorList plugin */
// null = show in all views
class MMTErrorSource extends DefaultErrorSource("MMT", null) {

   /** like superclass but allows only [[MMTError]]s */
   override def addError(e: DefaultErrorSource.DefaultError): Unit = {
      e match {
        case e: MMTError => super.addError(e)
        case _ => throw ImplementationError("illegal error")
      }
   }

   /** remove errors produced when checking this file */
   def removeMMTFileErrors(file: File): Unit = {
     val mmt : MMTPlugin = jEdit.getPlugin("info.kwarc.mmt.jedit.MMTPlugin", true).asInstanceOf[MMTPlugin]
     val sets = errors.values.iterator
     while (sets.hasNext) {
       val set = sets.next
       val es = set.iterator
       var remove: List[MMTError] = Nil
       while (es.hasNext) {
          es.next match {
            case e: MMTError =>
               if (e.mainFile == file) {
                 remove ::= e
               }
            case e =>
               // should be impossible
          }
       }
       remove.foreach {e =>
         errorCount -= 1
         set.remove(e)
       }
       /* ErrorList 2.4.0 has a bug where errors are not removed from the ErrorListPanel
          even though this error source removes them correctly and this method sends the right bus message.
          ErrorListPanel maintains a set of all errors and a tree model for displaying them.
          It's unclear if the failure is with both or only the latter, or if the messages are somehow faulty.
          We cannot use ErrorList 2.3.x anymore because it is not compatible with jEdit 5.7.
          Therefore, as a workaround, we clear all errors and readd them using the list maintained by the ErrorSource.
          As soon as ErrorList works correctly again, the commented-out code below should be reinstated.s
        */
       if (remove.nonEmpty) gui.Swing.invokeLater {
         val msg = new ErrorSourceUpdate(this, ErrorSourceUpdate.ERRORS_CLEARED)
         org.gjt.sp.jedit.EditBus.send(msg)
         getAllErrors.foreach {e =>
           val upd = new ErrorSourceUpdate(this, ErrorSourceUpdate.ERROR_ADDED, e)
           org.gjt.sp.jedit.EditBus.send(upd)
         }
       }
       /*if (remove.nonEmpty) gui.Swing.invokeLater {
         remove.foreach {e =>
            mmt.report("debug", "error removed: " + e.getErrorMessage)
            val msg = new ErrorSourceUpdate(this, ErrorSourceUpdate.ERROR_REMOVED, e)
            org.gjt.sp.jedit.EditBus.send(msg)
         }
       }
       */
     }
   }
}

/**
 * sends MMT errors directly to jEdit ErrorList
 * @param mainFile the source file, in which the errors are found
 */
class ErrorListForwarder(errorSource: MMTErrorSource, controller: Controller, mainFile: File) extends ErrorHandler {
   protected def addError(e: Error) : Unit = e match {
      case s: SourceError =>
         //generated by parsers
         // We permit the case that errors are found in other files than the current one. So we compute the file path
         val file = controller.backend.resolveLogical(s.ref.container) match {
            case Some((a, p)) => (a / source / p).toString
            case None => s.ref.container match {
               case utils.FileURI(f) => f.toString
               case u => u.toString
            }
         }
         val error = MMTError(mainFile, errorSource, s, file, s.ref.region, s.mainMessage, s.extraMessages)
         errorSource.addError(error)
      case e: Invalid =>
         //generated by checkers
         var mainMessage = e.shortMsg
         var extraMessages : List[String] = e.extraMessage.split("\n").toList
         val causeOpt: Option[metadata.HasMetaData] = e match {
            case e: InvalidObject => Some(e.obj)
            case e: InvalidElement => Some(e.elem)
            case e: InvalidUnit =>
               val steps = e.history.getSteps
               extraMessages :::= steps.map(_.present(o => controller.presenter.asString(o)))
               val declOpt = e.unit.component.map(p => controller.localLookup.get(p.parent))
               // WFJudgement must exist because we always start with it
               // find first WFJudgement whose region is within the failed checking unit
               declOpt flatMap {decl =>
                  SourceRef.get(decl).flatMap {bigRef =>
                     steps.mapFind {s =>
                       s.removeWrappers match {
                        case j: WFJudgement =>
                           SourceRef.get(j.wfo) flatMap {smallRef =>
                              if (bigRef contains smallRef) {
                                 mainMessage += ": " + controller.presenter.asString(j.wfo)
                                 Some(j.wfo)
                              } else
                                 None
                           }
                        case _ =>
                          None
                       }
                     }
                  }.orElse(declOpt)
               }
         }
         extraMessages :::= e.getAllCausedBy.map(_.toString)
         val ref = causeOpt.flatMap {cause => SourceRef.get(cause)}.getOrElse {
            mainMessage = "error with unknown location: " + mainMessage
            SourceRef(utils.FileURI(mainFile), SourceRegion(SourcePosition(0,0,0), SourcePosition(0,0,0)))
         }
         val error = MMTError(mainFile, errorSource, e, mainFile.toString, ref.region, mainMessage, extraMessages)
         errorSource.addError(error)
      case e: Error =>
         // other errors, should not happen
         val msg =  "error with unknown location: " + e.getMessage
         val error = new MMTError(mainFile, errorSource, e, mainFile.toString, 0, 0, 1, msg, stringToList(e.toStringLong,"\n"))
         errorSource.addError(error)
   }
}
