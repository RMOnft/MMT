package info.kwarc.mmt.aldor

import info.kwarc.mmt.api.utils._

/* Simplified syntax of Aldor as extracted from the axy files generated by Aldor
*
* Aldor is Curry-typed. The main type hierarchy is value:domain:category, where
* - category corresponds to a theory
* - domain corresponds to a model of a theory
* - value is an element of the carrier set of the domain
*
* Top-level declarations can take parameters and may return categories, domains, or other values.
* They may also extend existing (possibly parametric) domains by redefining them with an extended category.
*
* The logic of theories is Church-sorted.
* But every category implicitly has a type % that represents the domain of the most important single-sorted case.
* Domains define % using a definition for the special constant Rep (which can be seen as a plain assignment to %).
*
* The type system has
* - the usual base types
* - dependent function and product types
* - record types
* - categories as types (with the domains as the elements)
*
* The module system has
* - anonymous modules (which may in particular occur as the definiens of toplevel declarations) with an optional initial include
* - includes in anonymous modules (included constants may be defined later)
* - joins of modules
* Includes and joins are used for categories although they would make sense for domains, too.
* For domains, only the initial include is used.
* Duplicate constant names are allowed if the types differ.
* In that case a type attribution (surface) or type hash (kernel) is used to disambiguate.
* Duplicate includes of the same module are allowed, in particular to include the same parametric category with different agrguments.
* In that case, before accessing a field, %% attributions are used to view a domain according to the desired include.
* If the latter does not suffice to disambiguate (e.g., same include twice), the constants can be assumed to be equal.
*/

/** declarations */
abstract class ADeclaration {
  def addIf(c: Option[AExpression]): ADeclaration
}
/** plain constant at toplevel or inside a category or domain */
case class AConstant(id: AId, condition: Option[AExpression], params: List[ABinding], tp: Option[AExpression], df: Option[AExpression],
                     documentation: Option[String], default: Boolean = false) extends ADeclaration {
  def addIf(c: Option[AExpression]) = copy(condition=NormalizedCategory.mergeConditions(condition,c))
}
/** include in a category or domain */
case class AInclude(condition: Option[AExpression], cat: AExpression) extends ADeclaration {
  def addIf(c: Option[AExpression]) = copy(condition=NormalizedCategory.mergeConditions(condition,c))
}

object NormalizedCategory {
  def mergeConditions(c: Option[AExpression], d: Option[AExpression]) = (c,d) match {
    case (c,None) => c
    case (None,d) => d
    case (Some(e),Some(f)) => Some(AOperator("And", List(e,f)))
  }
  /** normal form: With(ANil,normal declarations) or atomic */
  def flatten(e:AExpression): AExpression = e match {
    case AWith(i,ds) =>
      AWith(ANil,(AInclude(None,i)::ds) flatMap flattenDecl)
    case AAdd(i,ds) =>
      AAdd(ANil,(AInclude(None,i)::ds) flatMap flattenDecl)
    case AJoin(_) =>
      flatten(AWith(e, Nil))
    case e => e
  }
  /** normal form: AConstant or AInclude of atomic category */
  def flattenDecl(d: ADeclaration): List[ADeclaration] = d match {
    case AInclude(c, AOperator(AParser.Comma.name, es)) =>
      es map {e => AInclude(c, e)} flatMap flattenDecl
    case AInclude(c,AJoin(es)) => es map {e => AInclude(c,e)} flatMap flattenDecl
    case AInclude(c,AWith(e,ds)) => (AInclude(c,e) :: ds.map(_.addIf(c))) flatMap flattenDecl
    case AInclude(c,AAdd(e,ds)) => (AInclude(c,e) :: ds.map(_.addIf(c))) flatMap flattenDecl
    case AInclude(c,AOperator(AParser.If.name, List(c2, th, ANil))) => flattenDecl(AInclude(mergeConditions(c,Some(c2)), th))
    case AInclude(_,ANil) => Nil
    case d => List(d)
  }
  def unapply(cat: AExpression): Option[List[ADeclaration]] = flatten(cat) match {
    case AWith(_,ds) => Some(ds)
    case _ => None
  }
}

/** expressions (representing categories, domain, types, or values) */
abstract class AExpression

/** built-in or user-declared identifier
  * @param kind
  *   Import: constant defined in some other scope and made available by an import statement
  *   Export: constant declared in the current module and exported
  *   LexConst: constant of the current module and not exported, or local variable bound in the current expression
  *   LexVar: constant of the current module and not exported, or local variable bound in the current expression
  *   Param: parameter of the declaration
  *   Extend: constant from an extension
  *   Label: labeled block for jumping
  *   Builtin: built-in constant
  *   Foreign: foreign constant
  *   (not sure if this classification is correct, needs to be checked in examples)
  * @param typeHash disambiguates between overloaded names
  */
case class AId(name: String, kind: Option[String], typeHash: Option[Int]) extends AExpression
/** the $ operator that accesses a component of a domain */
case class AQualify(id: AId, parent: AExpression) extends AExpression
/** other built-in operators */
case class AOperator(operator: String, args: List[AExpression]) extends AExpression
/** local variable */
case class ADeclare(name: String, tp: AExpression, df: Option[AExpression]) extends AExpression
/** assignment to variable */
case class AAssign(name: String, tp: AExpression, df: AExpression) extends AExpression
/** number literal */
case class ANum(n: Int) extends AExpression
/** string literal */
case class AString(s: String) extends AExpression
/** foreign constant */
case class AForeign(n: String, tp: AExpression) extends AExpression

/** dependent functions; Pi, Lambda, and function application may be nullary */
case class APi(bindings: List[ABinding], body: AExpression) extends AExpression
case class ALambda(bindings: List[ABinding], outType: Option[AExpression], body: AExpression) extends AExpression
case class AApply(fun: AExpression, args: List[AExpression]) extends AExpression

/** anonymous categories (in particular, occurring as the definiens of category-valued toplevel constants) */
case class AWith(left: AExpression, decls: List[ADeclaration]) extends AExpression
/** anonymous domains (in particular, occurring as the definiens of domain-valued toplevel constants) */
case class AAdd(left: AExpression, decls: List[ADeclaration]) extends AExpression
/** join of categories or domains */
case class AJoin(mods: List[AExpression]) extends AExpression
/** () */
case object ANil extends AExpression

/** record type */
case class ARecord(decls: List[ADeclaration]) extends AExpression

/** variable binding */
case class ABinding(name: Option[String], tp: AExpression, df: Option[AExpression])

/** parses S-AExpression in Aldor-generated asy files into the above syntax */
object AParser {
  def error(m: String) = throw info.kwarc.mmt.api.ParseError(m)
  // abbreviations for ids; these enable unapply-syntax
  val Id = SExpressionId("Id")
  val Qualify = SExpressionId("Qualify")
  /* matcher for possibly qualified ids */
  object QId {
    def unapply(e: SExpression) = e match {
      case Id(SExpressionId(n),SExpressionId(kd),SExpressionNumber(th)) => Some(AId(n,Some(kd),Some(th)))
      case Id(SExpressionId(n)) => Some(AId(n,None,None))
      case SExpressionId(n) => Some(AId(n,None,None))
      // rarely ids appear with a number, maybe a disambiguating index? we merge the number into the name
      case Id(SExpressionId(n),SExpressionNumber(i), SExpressionId(kd),SExpressionNumber(th)) =>
        Some(AId(n+"."+i.toString,Some(kd),Some(th)))
      case Id(SExpressionId(n),SExpressionNumber(i)) =>
        Some(AId(n+"."+i.toString,None,None))
      case _ => None
    }
  }
  val Declare = SExpressionId("Declare")
  val Define = SExpressionId("Define")
  val Local = SExpressionId("Local")
  val Default = SExpressionId("Default")
  val Import = SExpressionId("Import")
  val Export = SExpressionId("Export")
  val If = SExpressionId("If")
  val Label = SExpressionId("Label")
  val Comma = SExpressionId("Comma") // list of bindings
  val Sequence = SExpressionId("Sequence") // list of declarations or other
  val Join = SExpressionId("Join") // union of categories, possibly anonymous
  val JoinId = Id(Join, SExpressionId("Import"), SExpressionNumber(702595868))

  val Apply = SExpressionId("Apply")
  val Arrow = SExpressionId("->")
  val ArrowId = Id(Arrow, SExpressionId("Import"), SExpressionNumber(149175799))
  val Lambda = SExpressionId("Lambda")
  val With = SExpressionId("With")
  val Add = SExpressionId("Add")
  val Record = SExpressionId("Record")
  val RecordId = Id(Record, SExpressionId("Import"), SExpressionNumber(849204484))

  val Foreign = SExpressionId("Foreign")
  val Assign = SExpressionId("Assign")
  val Assert = SExpressionId("Assert")
  val Builtin = SExpressionId("Builtin")
  val Inline = SExpressionId("Inline")

  /* A declaration at toplevel or in a with/add-expression

     If a toplevel declaration's definiens is exported, the "define"-pair of type and definiens occurs only after
     the parameter bindings (which type and definiens share); these are bound by ->.
  */
  def declarations(s: SExpression): List[ADeclaration] = {
    s match {
      case Sequence(ds@_*) => ds.toList flatMap declarations
      case SExpressionList(Nil) => Nil
      // toplevel or in category
      case Declare(ns,tpdf,mt) =>
        def nameOrList(e: SExpression): List[AId] = e match {
          case QId(id) => List(id)
          case Comma(es@_*) => es.toList flatMap nameOrList
        }
        val names = nameOrList(ns)
        val (pars,(tp,df)) = tpdf match {
          case Apply(ArrowId, i,o) =>
            val bs = bindings(i)
            (bs,maybeDefine(o))
          case e =>
            (Nil,maybeDefine(e))
        }
        names map {id => AConstant(id,None,pars,Some(tp),df, getDocumentation(mt))}
      // untyped definition in domain, especially used for defining Rep
      case Define(QId(id), df) =>
        List(AConstant(id, None, Nil, None, Some(expr(df)), None))
      // typed definition in domain, typical case
      case Define(Declare(QId(id), tp, mt), df) =>
        List(AConstant(id, None, Nil, Some(expr(tp)), Some(expr(df)), getDocumentation(mt)))
      case Default(ds) =>
        declarations(ds) map {case c:AConstant => c.copy(default = true) case i: AInclude => i}
      // conditional declarations (else branch always empty when providing declarations)
      case If(test,ds,_) =>
        val testA = expr(test)
        val dsA = declarations(ds)
        dsA map {
          case c: AConstant => c.copy(condition = NormalizedCategory.mergeConditions(Some(testA), c.condition))
          case i: AInclude => i.copy(condition = NormalizedCategory.mergeConditions(Some(testA), i.condition))
        }
      case Local(_*) => Nil
      // makes identifiers available without qualifier, can be ignored
      case Import(_*) => Nil
      case Export(_*) =>
        Nil
      case Foreign(d, _) => declarations(d)
      case Inline(_*) => Nil // ???
      // imperative commands in a sequence of declarations
      case Assign(_*) =>  Nil // ???
      case Assert(_*) => Nil // ???
      case Builtin(d) => declarations(d)  // ???
      case s =>
        // println("treating unknown declaration as include: " + s.asList.head)
        List(AInclude(None, expr(s)))
    }
  }

  def getDocumentation(e: SExpression) = {
    e.asList.collectFirst {
      case SExpressionPair(SExpressionId("documentation"),SExpressionString(doc)) => doc
    }
  }

  /** an expression, including With/Add */
  def expr(s: SExpression): AExpression = {
    s match {
      case SExpressionNumber(n) => ANum(n)
      case SExpressionString(s) => AString(s)
      case Apply(ArrowId, bs, bd) => APi(bindings(bs), expr(bd))
      case Apply(JoinId, mods@_*) => AJoin(mods.toList map modexpr)
      case Apply(Id(Join), mods@_*) => AJoin(mods.toList map modexpr) // Join sometimes occurs without extra data
      // local definition
      case Declare(QId(id), tp, _) =>
        ADeclare(id.name, expr(tp), None)
      case Define(Declare(QId(id), tp, _), df) =>
        ADeclare(id.name, expr(tp), Some(expr(df)))
      // a different local definition
      case Assign(Declare(QId(id), tp, mt), df) =>
        AAssign(id.name, expr(tp), expr(df))
      // cut out labels
      case Label(_,e) => expr(e)
      case Apply(RecordId, ds@_*) => ARecord(ds.toList flatMap declarations)
      case Lambda(bs,rt,bd) => ALambda(bindings(bs), Some(expr(rt)), expr(bd))
      case With(e, ds) => AWith(expr(e), declarations(ds))
      case Add(e, ds) => AAdd(expr(e), declarations(ds))
      case Foreign(Declare(QId(id), tp, _), _) => AForeign(id.name, expr(tp))
      // general cases, must come last to allow for more specific cases above
      case Apply(fun, args @_*) => AApply(expr(fun), args.toList map expr)
      case Qualify(QId(id), parent) => AQualify(id, expr(parent))
      case QId(id) => id
      case Builtin(Declare(QId(id),tp,_)) => AOperator(id.name,List(expr(tp)))
      case SExpressionList(SExpressionId(op)::args) => AOperator(op, args map expr)
      case SExpressionList(Nil) => ANil
      case e =>
        error("unsupported expression: " + e.asList.head)
    }
  }
  def modexpr(s: SExpression): AExpression = {
    s match {
      // type annotated to anonymous domain
      case Define(Declare(_, cat), m) =>
        AJoin(List(expr(cat), expr(m)))
      case e => expr(e)
    }
  }
  /** a single variable binding/input type */
  def binding(s: SExpression): ABinding = {
    s match {
      // named
      case Declare(SExpressionId(n), tp, _) => ABinding(Some(n), expr(tp), None)
      // named and (?) disambiguated
      case Declare(SExpressionId(n), SExpressionNumber(i), tp, _) => ABinding(Some(n+i), expr(tp), None)
      // defined
      case Define(Declare(SExpressionId(n), tp, _), df) => ABinding(Some(n), expr(tp), Some(expr(df)))
      // unnamed
      case e => ABinding(None, expr(e), None)
    }
  }
  /** a list of bindings */
  def bindings(s: SExpression) = {
      s match {
        case Comma(is@_*) => is.toList map binding
        case e => List(binding(e))
      }
  }
  /** a type and the optional definiens
    * By default Aldor only exports the type of a declaration even if a definiens is present.
    * If the "define" keyword is used, the type is paired with the definiens.
    */
  def maybeDefine(s: SExpression): (AExpression,Option[AExpression]) =
    s match {
      case Define(Declare(_, tp), df) => (expr(tp),Some(expr(df)))
      case e => (expr(e),None)
    }
}