package info.kwarc.mmt

/**
  * The code in this package was taken from the trepplein type checker for Lean
  * at https://github.com/gebner/trepplein, version 1.1, c704ffe81941779dacf9efa20a75bf22832f98a9.
  * See there for license, contributors, etc.
  *
  * It was modified as follows:
  * - the main method was removed
  * - the parser was adjusted to allow for Windows file endings (which are produced when Lean is run under Windows)
  * - this documentation was added.
  *
  * The general structure is as follows:
  *
  * parser.scala parses the low-level text export files that lean produces when run with the command line arguments "--export=FILE".
  * Each declaration is one line and consists of letters represent constructor applications and
  * numbers referring to previously introduced names.
  * This additionally takes the files to process or --recursive to process all files in the current folder.
  * It produces lists of surface declarations (called Modification) and notations.
  *
  * environment.scala, quotient.scala, inductive.scala, expr.scala, level.scala, name.scala contain the AST.
  * The surface declarations are axioms, definitions, and inductive and quotient type definitions.
  * A Modification has a method compile that elaborates it into kernel declarations;
  * the elaboration result is captured in the class CompiledModfification, which has methods
  * - decls: of type Declaration, which is essentially the same as an AxiomModification.
  * - rules: of type ReductionRule, which is a conditional rewrite rule.
  * - check: imperative code to check declaration
  * The elaboration of axioms and definitions is trivial.
  * Environment and PreEnvironment store lists of the above, but they are not used. They are kept for reference only.
  *
  * The classes for expressions (Expr), levels (Level, = universes), and names (Name) are self-explanatory.
  * Names are hierarchic with Anon as the root and strings or numbers as parts.
  *
  * typechecker.scala, reduction.scala implement a type-checker for the AST.
  * pretty.scala implements a pretty-printer for the AST, and doc.scala provides formatting for messages generated by the type-checker.
  * These are not used and are kept for reference only (because they define the semantics of the AST).
  *
  * unionfind.scala is used in the expression cache.
  *
  * Lean does not have theories in the MMT sense.
  * Declarations are spread over files, which are made available using import FOLDER.FILE and form a single toplevel.
  * Within files, qualified names can be introduced using namespace declarations.
  *
  * Lean's export files represent that single toplevel (actually: the subset of it that is in the dependency cone of whatever was checked).
  * They do not allow recovering which file a declaration is from.
  *
  */
package object lean {}
